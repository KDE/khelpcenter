Design for a possible reimplementation of the KDE help center
$Id$
=============================================================

Preludium
---------
This document presents an alternative design for a 'help center' applicaiton
in KDE. Lines which start with a # are supposed to be thoughts I had while
writing this, much like the stuff you write on the side of a page when reading
a book.

General
-------
- main() instantiates a KHC::Application
- KHC::Application() deals with parsing the commandline parameters and
  instantiates a KHC::MainWindow
- KHC::MainWindow creates the main UI, setting up actions, using a QSplitter
  as it's mainwidget to separate a KHC::Navigator at the left from a KHC::View
  at the right

That's the simple part. ;-)

KHC::Navigator
--------------

KHC::Navigator inherits QTabWidget and provides, on two tabs, a
KHC::ContentsTab object and a KHC::SearchTab object.

1.) KHC::ContentsTab provides the following entires:
	- Welcome to KDE
	- KDE user's manual
	- KDE FAQ
	- Contact information
	- Supporting KDE

# Should we create an extra item for these five and put them in there?
# Something like "General KDE" or so? OTOH that makes them less visible, and
# these are really ought to be seen. - Frerich

	- Application manuals
	- Tutorials
	- UNIX man pages
	- UNIX info pages
	- Glossary

# Do we really need this "Tutorials" item at all? right now it holds only two
# items, perhaps we can get rid of it. - Frerich

The first five items are generated by KHC::Navigator itself and are direct
links to KDE documentations. The work of generating each of the last four
items is (with one exception) delegated to four helper classes, whic inherit a
'KHC::TreeBuilder' class which has the following interface:

class KHC::TreeBuilder
	virtual void build( KListViewItem *parent ) = 0;

# This concept of using a TreeBuilder baseclass might make it possible to turn
# all the classes which use that interface into plugins. That way we could
# e.g. have a ScrollKeeper plugin. - Frerich

The classes which inherit this interface are:
	- KHC::ManualTreeBuilder: responsible for generating the tree below the
	  "Application manuals" item
	- KHC::TOCBuilder: responsible for generating a TOC tree below each of the
	  manual trees items, so that you can choose Application
	  Manuals->Editors->KWrite->Using KWrite->Menu bar transparently. This is
	  the only builder which is not instantiated by KHC::ContentsTab but
	  instead instantiated by KHC::ManualTreeBuilder
	- KHC::TutorialTreeBuilder: responsible for generating the tree below the
	  "Tutorials" item
	- KHC::ManTreeBuilder: responsible for building the tree below the "UNIX
	  man pages" item
	- KHC::InfoTreeBuilder: responsible for building the tree below the "UNIX
	  info pages" item
	- KHC::GlossaryTreeBuilder: guess what

2.) KHC::SearchTab provides a widget which lets the search through all
available help repositories, also defining some flags such as 'Search by
regexp' or 'Search case sensitive'.

# I think this means that we have to create a 'DataCollection' class which
# gets inherited by all classes which are "searchable". DataCollections should
# also be able to contains multiple child DataCollection, so that we have e.g.
# one DataCollection per application manual, and one "Manuals" collection
# which contains all the application manual collections.
# We'd probably also need a DataCollection for the info pages and man pages.
# And later, in the far future, we might extent this concept to web searches,
# so that e.g. Google represents a DataCollection which we can query.
# I'm not yet decided how to do that properly, perhaps using multiple
# inheritance, so that each TOCBuilder is a DataCollection - naw, we'd rather
# have a "TableOfContents" class which contains a TOCBuilder, and is a
# datacollection? Hm, not sure.
# In any case DataCollections should some sort of plugins, so that we can add
# e.g. new web search interfaces lateron.
# - Frerich

KHC::View
---------
KHC::View inherits KHTMLPart and does the actual job of showing some sort of
document. Most importantly, it has a slot which passes it a KURL pointing to a
document to show. KHC::View will invoke kio_help if necessary (if the URL's
protocol == "help") by itself and otherwise use the plain URL.

# TODO: Things I didn't really think about yet: the interface between the
# navigator and the view. I think this has to be a bidirectional association
# since the navigator can change the view (e.g. by clicking on a manual which
# shows it in the view), but the view can also change the navigator (think of
# clicking on a 'See also' link in the glossary which should also scroll to
# the corresponding entry in the navigator).
# Also, the whole search engine needs more thought, that DataCollection idea
# seems promising to me but I'm not yet decided on how to do it properly.

# I just thought about this a bit, I think KHC::MainWindow should act as the
# interface between KHC::Navigator and KHC::View.
#
# Another thing: KHC::MainWindow really really shouldn't care about managing
# the history - we'd introduce a dedicated KHC::History class for that, a
# singleton which is responsible for managing the history entries (a
# struct 'KHC::History::Entry' perhaps), plugging in the actions into the UI,
# that stuff. To implement a history we have currently two approaches AFAICS:
#
# - either we use the current approach, which is that the state of the
# application gets stored in a QByteArray member of the History::Entry - right
# now this only caputres the state of the KHC::View, which means that we
# probably have to implement an operator<<() for a bunch of classes, too -
# namely the Navigator. I dislike this brute force approach since we cannot
# control what gets saved but only when we do the snapshot of the state
# - Or we use a KCommand which encapsulates functionality which should be
# undoable. I think this is preferred because it not only caputres the time of
# the snapshot but also the functionality, plus that it's probably far less
# memory hungry.
#
# Either way, we should probably rip out all the history stuff from MainWindow
# first (makes up ~75% of the code) and extract it into a separate class.
